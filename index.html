<!DOCTYPE html>
 <html lang="en">
 <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BeaconGen 2025 - Cadastral Beacon System</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css"
rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
rel="stylesheet">
    <style>
        /* Custom CSS for animations and styling */
        body {
            font-family: 'Inter', sans-serif;
        }
        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        .gradient-bg {
            background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #581c87 100%);
        }
        .card-shadow {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transition: all 0.3s ease;
        }
        .card-shadow:hover {
            box-shadow: 0 35px 60px -12px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        .map-container {
            height: 450px;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .beacon-marker {
            position: absolute;
            color: #dc2626;
            font-size: 24px;
            animation: bounce 2s infinite;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .beacon-marker:hover {
            transform: scale(1.2);
        }
        .beacon-marker:hover { /* This CSS rule has a duplicate selector and missing property/value */
            color: #991b1b;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.4s ease;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        .notification.show {
            transform: translateX(0);
        }
        .notification.success { background: linear-gradient(135deg, #10b981, #059669); }
        .notification.error { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .notification.warning { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .batch-results {
            max-height: 300px;
            overflow-y: auto;
        }
        .beacon-item {
            transition: all 0.3s ease;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
        }
        .beacon-item:hover {
            transform: translateX(8px);
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            border-color: #0ea5e9;
        }
        .file-upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 32px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        }
        .file-upload-area:hover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            transform: translateY(-2px);
        }
        .file-upload-area.dragover {
            border-color: #2563eb;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        }
        .uploaded-file {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #0ea5e9;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
        }
        .uploaded-file:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.2);
        }
        .unique-beacon-display {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 24px;
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
        }
        .stats-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease;
        }
        .stats-card:hover {
            border-color: #3b82f6;
            transform: translateY(-4px);
        }
        .form-input {
            transition: all 0.3s ease;
        }
        .form-input:focus {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(37, 99, 235, 0.3);
        }
        .activity-item {
            transition: all 0.3s ease;
            border-radius: 8px;
            padding: 16px;
            margin: 8px 0;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
        }
        .activity-item:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .validation-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
        }
        .validation-error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
        }
        .coordinates-display {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            padding: 16px;
            border-radius: 8px;
            margin: 12px 0;
            font-family: monospace;
        }
        .quota-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            margin: 12px 0;
        }
        .quota-limit {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            margin: 12px 0;
        }
        footer p {
            font-family: 'Georgia', serif;
            font-size: 0.95rem;
            color: #4b5563;
        }
        input[required]::placeholder,
        select[required] option:first-child,
        textarea[required]::placeholder {
            color: #9CA3AF;
        /* Tailwind's gray-400 */
        }
        input:invalid,
        select:invalid,
        textarea:invalid {
            border-color: #F87171;
        /* Tailwind's red-400 */
        }
        /* New styles for generatedBeacons display */
        .generated-beacons-display-custom {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
        /* Light green to
medium green */
            border: 1px solid #34d399;
        /* A more vibrant green border */
            border-radius: 0.5rem;
        /* Equivalent to rounded-md */
            padding: 1rem;
        /* Equivalent to p-4 */
        }
        .search-results-card {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bfdbfe;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-size: 1.5rem;
            color: #3b82f6;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
<script type="module">
    // ALL import statements MUST be here, at the very top level of the module
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-analytics.js";
    import {
        getFirestore,
        collection,
        doc,
        getDoc,
        setDoc,
        updateDoc,
        addDoc
    } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

    document.addEventListener('DOMContentLoaded', async () => {
        const loadingOverlay = document.getElementById('loadingOverlay');
        const systemStatusText = document.getElementById('systemStatusText');

        try {
            // Your Firebase configuration
            const firebaseConfig = {
                apiKey: "AIzaSyCRvbMx747ZQL2DTSIm2bywOGHf7JJg7vA", // Use your actual API Key
                authDomain: "beacon-35989.firebaseapp.com",
                projectId: "beacon-35989",
                storageBucket: "beacon-35989.appspot.com",
                messagingSenderId: "130634267193",
                appId: "1:130634267193:web:cdb103cd71cda24ba62be8",
                measurementId: "G-ZG50RM7P47"
            };

            // Initialize Firebase and Firestore
            const app = initializeApp(firebaseConfig);
            const analytics = getAnalytics(app);
            const db = getFirestore(app);

            // Fetch the test document
            const docRef = doc(db, "testCollection", "testDoc");
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                console.log("✅ Document data:", docSnap.data());
                if (systemStatusText) {
                    systemStatusText.innerHTML = '<span class="text-white font-semibold">System Status: <span class="text-green-200">Online and Connected to Firestore!</span></span>';
                }
            } else {
                console.log("❌ No such document!");
                if (systemStatusText) {
                    systemStatusText.innerHTML = '<span class="text-white font-semibold">System Status: <span class="text-yellow-200">Online, but test document not found.</span></span>';
                }
            }

        } catch (error) {
            console.error("Error during Firebase initialization or data fetch:", error);
            if (systemStatusText) {
                systemStatusText.innerHTML = `<span class="text-white font-semibold">System Status: <span class="text-red-200">Connection Error!</span></span><p class="text-xs text-red-200">${error.message}</p>`;
            }
        } finally {
            // This hides the loading overlay
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }

        // Global variables for date and surveyor data
        const currentDate = new Date();
        const currentYear = currentDate.getFullYear();
        const currentQuarter = Math.floor(currentDate.getMonth() / 3) + 1; // 1-indexed quarter

        // Firebase variables (will be initialized after SDK loads)
        let app, db, auth;
        let userId; // Will store the authenticated user's ID

        // Function to format the current date as "Month Day, Year"
        function getFormattedDate(date) {
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Update year displays
        document.getElementById("footerYear").innerText = currentYear;
        document.getElementById("yearText").innerText = currentYear;

        // Surveyor data: Prefix to Name mapping (will be populated from Firestore)
        let surveyors = {};
        // Surveyor beacon usage: { "Prefix": { "YYYY-QX": count, ... } } (will be populated from Firestore)
        // Initialized to "AA0000" and will be advanced based on historical data loaded from Firestore.
        let surveyorBeaconUsage = {};
        let lastBeaconSerialNum = "AA0000"; // Global variable to keep track of the last generated serial in "AA0000" format

        // Global Set to store all beacon IDs generated in the current session for validation
        // This will be populated from Firestore on load.
        const generatedBeaconsHistory = new Set();

        // Activity log array (will be populated from Firestore)
        let activityLog = [];

        // DOM elements
        const surveyorSelect = document.getElementById("surveyorSelect");
        const surveyorQuotaDisplay = document.getElementById("surveyorQuota");
        const beaconForm = document.getElementById("beaconForm");
        const beaconCountInput = document.getElementById("beaconCount");
        const uniqueBeaconIdDisplay = document.getElementById("uniqueBeaconId");
        const generatedBeaconsDiv = document.getElementById("generatedBeacons");
        const beaconsListDiv = document.getElementById("beaconsList");
        const coordinatesListDiv = document.getElementById("coordinatesList");
        const totalBeaconsStat = document.getElementById("totalBeacons");
        const parcelsCountStat = document.getElementById("parcelsCount");
        const gisPointsStat = document.getElementById("gisPoints");
        const activityLogDiv = document.getElementById("activityLog");
        const searchBeaconInput = document.getElementById("searchBeacon");
        const validateBtn = document.getElementById("validateBtn");
        const validationResultsDiv = document.getElementById("validationResults");
        const validationContentDiv = document.getElementById("validationContent");
        const fileUploadArea = document.getElementById("fileUploadArea");
        const recceDiagramInput = document.getElementById("recceDiagram");
        const uploadedFilesDiv = document.getElementById("uploadedFiles");
        const enhanceDescriptionBtn = document.getElementById("enhanceDescriptionBtn");
        const summarizeDescriptionBtn = document.getElementById("summarizeDescriptionBtn");
        const descriptionTextarea = document.getElementById("description");
        const llmOutputContainer = document.getElementById("llmOutputContainer");
        const llmOutputText = document.getElementById("llmOutputText");
        const llmLoadingSpinner = document.getElementById("llmLoadingSpinner");
        const copyLlmOutputBtn = document.getElementById("copyLlmOutputBtn");
        const clearLlmOutputBtn = document.getElementById("clearLlmOutputBtn");
        const generatedUniqueIdSpan = document.getElementById("generatedUniqueId");
        const totalGeneratedSpan = document.getElementById("totalGenerated");
        const displayParcelAreaSpan = document.getElementById("displayParcelArea");
        const systemStatusText = document.getElementById("systemStatusText");
        const activeSurveyorsStat = document.getElementById("activeSurveyors");
        const newPrefixInput = document.getElementById("newPrefix");
        const newNameInput = document.getElementById("newName");
        const searchSurveyorNameInput = document.getElementById("searchSurveyorName");
        const searchSurveyorBtn = document.getElementById("searchSurveyorBtn");
        const surveyorSearchResultsDiv = document.getElementById("surveyorSearchResults");
        const surveyorDetailsDiv = document.getElementById("surveyorDetails");

        // Get references to the "Add Surveyor" button and its input fields
        const addSurveyorBtn = document.getElementById('addSurveyorBtn'); // Ensure your button has this ID now
        // newPrefixInput and newNameInput are already declared above this line

        // Add event listener for the "Add Surveyor" button
        addSurveyorBtn.addEventListener('click', async () => {
            const prefix = newPrefixInput.value.trim().toUpperCase(); // Convert to uppercase for consistency
            const name = newNameInput.value.trim();

            if (!prefix || !name) {
                showNotification('Please enter both Prefix and Surveyor Name.', 'error');
                return;
            }

            try {
                // Use setDoc to create/overwrite a document with the prefix as its ID
                await setDoc(doc(db, "surveyors", prefix), {
                    name: name,
                    createdAt: new Date(),
                    // You might want to add initial quota usage here, e.g.,
                    // usage: { "2025-Q1": 0 }
                });

                showNotification(`Surveyor "${name}" (${prefix}) added successfully!`, 'success');
                console.log("New surveyor added with ID:", prefix);

                // Clear the input fields
                newPrefixInput.value = '';
                newNameInput.value = '';

                // Optionally, reload surveyor data into the select dropdown if you have that functionality
                // await loadSurveyorData(); // Assuming you have a function to load surveyors into a dropdown

            } catch (e) {
                console.error("Error adding new surveyor:", e);
                showNotification(`Error adding surveyor: ${e.message}`, 'error');
            }
        });


        // Utility function to show notifications
        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.getElementById('notificationContainer');
            notification.innerText = message;
            notification.className = `notification ${type}`; // Reset classes and apply new type
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }

        // Function to update the unique beacon ID display
        function updateUniqueBeaconIdDisplay() {
            // This is a placeholder; actual logic would involve fetching the last ID from Firestore
            // and incrementing it based on the current year/quarter.
            uniqueBeaconIdDisplay.innerText = `SC/ED ${lastBeaconSerialNum}AZ`;
        }

        // Helper to format date for activity log
        function formatActivityDate(date) {
            const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
            return date.toLocaleDateString('en-US', options);
        }

        // Function to add an activity to the log
        function addActivity(description) {
            const timestamp = new Date();
            activityLog.unshift({ description, timestamp }); // Add to the beginning
            renderActivityLog();
            // In a real app, you would save this to Firestore
        }

        // Function to render the activity log
        function renderActivityLog() {
            activityLogDiv.innerHTML = '';
            activityLog.forEach(activity => {
                const activityItem = document.createElement('div');
                activityItem.className = 'activity-item flex items-center justify-between text-gray-700';
                activityItem.innerHTML = `
                    <div>
                        <p class="font-medium">${activity.description}</p>
                        <p class="text-xs text-gray-500">${formatActivityDate(activity.timestamp)}</p>
                    </div>
                    <span class="text-xs text-gray-400"></span>
                `;
                activityLogDiv.appendChild(activityItem);
            });
        }

        // Function to generate a new beacon serial number (e.g., AA0000, AA0001, AB0000)
        function generateNextBeaconSerial(lastSerial) {
            if (!lastSerial) return "AA0000";

            let prefix = lastSerial.substring(0, 2);
            let num = parseInt(lastSerial.substring(2), 10);

            num++;
            if (num > 9999) {
                num = 0;
                let char2 = prefix.charCodeAt(1);
                char2++;
                if (char2 > 'Z'.charCodeAt(0)) {
                    char2 = 'A'.charCodeAt(0);
                    let char1 = prefix.charCodeAt(0);
                    char1++;
                    if (char1 > 'Z'.charCodeAt(0)) {
                        // This case means you've exhausted all AA0000 to ZZ9999
                        // In a real system, you'd handle this by rolling over or extending the format
                        showNotification("Beacon serial numbers exhausted for current format!", "error");
                        return "AA0000"; // Or throw an error, or change format
                    }
                    prefix = String.fromCharCode(char1) + String.fromCharCode(char2);
                } else {
                    prefix = prefix.charAt(0) + String.fromCharCode(char2);
                }
            }
            return prefix + String(num).padStart(4, '0');
        }

        // Function to generate a batch of beacon numbers
        function generateBeacons(count, surveyorPrefix, originLat, originLon, parcelArea, lga) {
            const generated = [];
            const coordinates = [];
            let currentSerial = lastBeaconSerialNum;

            for (let i = 0; i < count; i++) {
                currentSerial = generateNextBeaconSerial(currentSerial);
                const beaconId = `SC/ED ${surveyorPrefix}${currentSerial}AZ`;
                generated.push(beaconId);
                // For simplicity, other beacon coordinates are just incremented from origin
                // In a real GIS, this would involve spatial algorithms and RECCE diagram analysis.
                coordinates.push({
                    beaconId: beaconId,
                    latitude: (parseFloat(originLat) + (i * 0.00005)).toFixed(5),
                    longitude: (parseFloat(originLon) + (i * 0.00005)).toFixed(6)
                });
            }

            lastBeaconSerialNum = currentSerial; // Update the global tracker
            return { beacons: generated, coordinates: coordinates };
        }

        // Function to display generated beacons
        function displayGeneratedBeacons(beacons, coords, uniqueId, totalCount, area) {
            beaconsListDiv.innerHTML = '';
            coords.forEach(coord => {
                const beaconItem = document.createElement('div');
                beaconItem.className = 'beacon-item flex justify-between items-center';
                beaconItem.innerHTML = `
                    <p class="font-semibold text-gray-800">${coord.beaconId}</p>
                    <p class="text-sm text-gray-600">Lat: ${coord.latitude}, Lon: ${coord.longitude}</p>
                `;
                beaconsListDiv.appendChild(beaconItem);
            });

            coordinatesListDiv.innerHTML = '';
            coords.forEach(coord => {
                const coordItem = document.createElement('p');
                coordItem.className = 'text-sm';
                coordItem.innerText = `${coord.beaconId}: Lat ${coord.latitude}, Lon ${coord.longitude}`;
                coordinatesListDiv.appendChild(coordItem);
            });

            generatedUniqueIdSpan.innerText = uniqueId;
            totalGeneratedSpan.innerText = totalCount;
            displayParcelAreaSpan.innerText = area;
            generatedBeaconsDiv.classList.remove('hidden');
            showNotification('Beacons generated successfully!', 'success');
        }

        // Function to update statistics
        function updateStats() {
            // This function would fetch data from Firestore for actual counts
            // For now, we'll use dummy data or session data
            totalBeaconsStat.innerText = (parseInt(totalBeaconsStat.innerText) +
beaconsListDiv.children.length).toString();
            parcelsCountStat.innerText = (parseInt(parcelsCountStat.innerText) + 1).toString();
            gisPointsStat.innerText = (parseInt(gisPointsStat.innerText) +
coordinatesListDiv.children.length).toString();
            activeSurveyorsStat.innerText = Object.keys(surveyors).length; // Update based on loaded surveyors
        }

        // Function to handle beacon form submission
        beaconForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            loadingOverlay.classList.remove('hidden');

            const surveyorPrefix = surveyorSelect.value;
            const beaconCount = parseInt(beaconCountInput.value);
            const latitude = latitudeInput.value;
            const longitude = longitudeInput.value;
            const parcelArea = parcelAreaInput.value;
            const lga = lgaSelect.value;
            const description = descriptionTextarea.value;
            const recceFile = recceDiagramInput.files[0];

            if (!surveyorPrefix || !beaconCount || !latitude || !longitude || !lga || !recceFile) {
                showNotification('Please fill all required fields, including RECCE Diagram.', 'error');
                loadingOverlay.classList.add('hidden');
                return;
            }

            if (!recceFile) {
                showNotification('RECCE Diagram is required for GIS integration.', 'error');
                loadingOverlay.classList.add('hidden');
                return;
            }

            // Simulate file upload and GIS processing
            await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate API call

            const { beacons, coordinates } = generateBeacons(beaconCount, surveyorPrefix, latitude, longitude, parcelArea, lga);
            const uniqueId = `SC/ED ${surveyorPrefix}${lastBeaconSerialNum}AZ`;

            displayGeneratedBeacons(beacons, coordinates, uniqueId, beaconCount, parcelArea);
            updateStats();
            addActivity(`Generated ${beaconCount} beacons for ${surveyorPrefix} in ${lga}.`);

            // Save to Firestore (simplified - actual implementation needs proper data structure)
            try {
                await addDoc(collection(db, "generatedBeacons"), {
                    surveyorPrefix,
                    beaconCount,
                    latitude,
                    longitude,
                    parcelArea,
                    lga,
                    description,
                    generatedBeacons: beacons,
                    coordinates: coordinates,
                    timestamp: new Date(),
                    uniqueId: uniqueId,
                    recceFileName: recceFile ? recceFile.name : 'N/A'
                });

                // Update surveyor usage quota
                const currentQuarterKey = `${currentYear}-Q${currentQuarter}`;
                const surveyorDocRef = doc(db, "surveyors", surveyorPrefix);
                const surveyorDocSnap = await getDoc(surveyorDocRef);

                let currentUsage = 0;
                if (surveyorDocSnap.exists() && surveyorDocSnap.data().usage && surveyorDocSnap.data().usage[currentQuarterKey]) {
                    currentUsage = surveyorDocSnap.data().usage[currentQuarterKey];
                }

                await updateDoc(surveyorDocRef, {
                    [`usage.${currentQuarterKey}`]: currentUsage + beaconCount,
                    lastBeaconSerialNum: lastBeaconSerialNum // Save the last serial for this surveyor/system
                }, { merge: true }); // Merge to avoid overwriting other fields

                // Also update the global lastBeaconSerialNum in a separate document or a specific field in the system config.
                await setDoc(doc(db, "systemConfig", "beaconing"), { lastBeaconSerialNum: lastBeaconSerialNum }, { merge: true });

                showNotification('Beacon data saved to cloud!', 'success');
                // Clear form or reset
                beaconForm.reset();
                recceDiagramInput.value = ''; // Clear file input
                uploadedFilesDiv.innerHTML = '';
                llmOutputText.innerText = '';
                llmOutputContainer.classList.add('hidden');
                await loadSurveyorData(); // Reload to update quotas
            } catch (error) {
                console.error("Error saving beacon data or updating usage:", error);
                showNotification(`Error saving data: ${error.message}`, 'error');
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        });

        // Function to validate beacon number
        validateBtn.addEventListener('click', () => {
            const beaconToSearch = searchBeaconInput.value.trim().toUpperCase();
            validationContentDiv.innerHTML = '';
            validationResultsDiv.classList.remove('hidden');

            if (!beaconToSearch) {
                validationContentDiv.innerHTML = '<p class="validation-error">Please enter a beacon number to validate.</p>';
                return;
            }

            const pattern = /^SC\/ED [A-Z]{2}\d{4}[A-Z]{2}$/;
            if (!pattern.test(beaconToSearch)) {
                validationContentDiv.innerHTML = `
                    <p class="validation-error">
                        <i class="fas fa-times-circle mr-2"></i>Invalid Format! Expected: SC/ED AA0000AZ
                    </p>
                `;
                return;
            }

            // In a real app, you would query Firestore or a backend database
            // For now, simulate lookup against session-generated beacons or a dummy set
            if (generatedBeaconsHistory.has(beaconToSearch)) {
                validationContentDiv.innerHTML = `
                    <p class="validation-success">
                        <i class="fas fa-check-circle mr-2"></i>Beacon ${beaconToSearch} is VALID and recorded!
                    </p>
                    <p class="text-sm text-gray-700 mt-2">Details: Generated in current session.</p>
                `;
                showNotification('Beacon validated successfully!', 'success');
            } else {
                validationContentDiv.innerHTML = `
                    <p class="validation-error">
                        <i class="fas fa-times-circle mr-2"></i>Beacon ${beaconToSearch} not found or invalid.
                    </p>
                    <p class="text-sm text-gray-700 mt-2">It might be an old beacon, or not registered in the system.</p>
                `;
                showNotification('Beacon not found or invalid.', 'warning');
            }
        });

        // File upload area drag and drop functionality
        fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUploadArea.classList.add('dragover');
        });

        fileUploadArea.addEventListener('dragleave', () => {
            fileUploadArea.classList.remove('dragover');
        });

        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('dragover');
            recceDiagramInput.files = e.dataTransfer.files;
            displayFileName();
        });

        fileUploadArea.addEventListener('click', () => {
            recceDiagramInput.click();
        });

        recceDiagramInput.addEventListener('change', displayFileName);

        function displayFileName() {
            uploadedFilesDiv.innerHTML = '';
            if (recceDiagramInput.files.length > 0) {
                const file = recceDiagramInput.files[0];
                const fileElement = document.createElement('div');
                fileElement.className = 'uploaded-file';
                fileElement.innerHTML = `
                    <span class="text-sm text-blue-800 font-medium"><i class="fas fa-file-alt mr-2"></i>${file.name}</span>
                    <button type="button" class="text-red-500 hover:text-red-700 text-lg" onclick="removeFile()">
                        <i class="fas fa-times-circle"></i>
                    </button>
                `;
                uploadedFilesDiv.appendChild(fileElement);
                showNotification(`File "${file.name}" ready for upload!`, 'info');
            }
        }

        function removeFile() {
            recceDiagramInput.value = ''; // Clear the input
            uploadedFilesDiv.innerHTML = ''; // Clear the display
            showNotification('RECCE Diagram removed.', 'info');
        }

        // Gemini API Integration (Placeholder)
        async function callGeminiAPI(prompt) {
            llmOutputText.innerText = '';
            llmLoadingSpinner.classList.remove('hidden');
            llmOutputContainer.classList.remove('hidden');

            try {
                // In a real application, you would send this prompt to your backend
                // which then calls the Gemini API securely.
                // This is a client-side simulation.
                const simulatedResponse = await new Promise(resolve => setTimeout(() => {
                    if (prompt.includes("summarize")) {
                        resolve("This parcel, located in [LGA], is a [parcelArea] hectare land primarily for [purpose derived from description]. Origin coordinates recorded for GIS. Designed for cadastral beacon deployment.");
                    } else {
                        resolve("This parcel is situated in a strategic area of [LGA], spanning approximately [parcelArea] hectares. Its primary purpose is [detailed purpose derived from description], facilitating organized land division and precise cadastral beacon placement with full GIS integration capabilities.");
                    }
                }, 2000)); // Simulate network delay

                llmOutputText.innerText = simulatedResponse;
                showNotification('LLM processing complete!', 'success');
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                llmOutputText.innerText = 'Error processing description. Please try again.';
                showNotification('Failed to process description.', 'error');
            } finally {
                llmLoadingSpinner.classList.add('hidden');
            }
        }

        enhanceDescriptionBtn.addEventListener('click', () => {
            const originalDescription = descriptionTextarea.value.trim();
            if (!originalDescription) {
                showNotification('Please enter a parcel description first.', 'warning');
                return;
            }
            const prompt = `Enhance the following parcel description for a cadastral beacon system, making it more professional and detailed, suitable for official records and GIS integration. Original description: "${originalDescription}"`;
            callGeminiAPI(prompt);
        });

        summarizeDescriptionBtn.addEventListener('click', () => {
            const originalDescription = descriptionTextarea.value.trim();
            if (!originalDescription) {
                showNotification('Please enter a parcel description first.', 'warning');
                return;
            }
            const prompt = `Given the following parcel description, please provide a concise summary
highlighting the key characteristics and purpose of the parcel. Keep it brief and to the point.
Original description: "${originalDescription}"`;
            callGeminiAPI(prompt);
        });
        copyLlmOutputBtn.addEventListener('click', () => {
            const textToCopy = llmOutputText.innerText;
            if (textToCopy) {
                // Using document.execCommand('copy') for better iframe compatibility
                const textarea = document.createElement('textarea');
                textarea.value = textToCopy;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showNotification('LLM output copied to clipboard!', 'success');
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    showNotification('Failed to copy text to clipboard.', 'error');
                }
                document.body.removeChild(textarea);
            }
        });
        clearLlmOutputBtn.addEventListener('click', () => {
            llmOutputText.innerText = '';
            llmOutputContainer.classList.add('hidden');
            showNotification('LLM output cleared.', 'info');
        });
    }); // End of DOMContentLoaded listener
    </script>
 </body>
 </html>
